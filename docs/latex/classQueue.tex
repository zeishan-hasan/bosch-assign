\hypertarget{classQueue}{}\doxysection{Queue$<$ T $>$ Class Template Reference}
\label{classQueue}\index{Queue$<$ T $>$@{Queue$<$ T $>$}}


A thread-\/safe queue implementation.  




{\ttfamily \#include $<$bosch-\/assign.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classQueue_a66872b8cc7fc722d02c14bb5816ab2c2}{Queue}} (int n)
\begin{DoxyCompactList}\small\item\em Constructs a new \mbox{\hyperlink{classQueue}{Queue}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classQueue_aa7eef1b427e24555780505de20e9acbc}{$\sim$\+Queue}} ()
\begin{DoxyCompactList}\small\item\em Destroys the \mbox{\hyperlink{classQueue}{Queue}} object. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classQueue_ad2779bcb60e23b597662c393bf04271c}{count}} ()
\begin{DoxyCompactList}\small\item\em Gets the number of elements in the queue. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classQueue_a03312b60344e10adc76501434b2852f6}{set\+\_\+is\+\_\+done}} ()
\begin{DoxyCompactList}\small\item\em Sets the \char`\"{}is\+\_\+done\char`\"{} flag to indicate the producer is done. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classQueue_a22e0b575ea62157eaf947b6845d0b560}{get\+\_\+is\+\_\+done}} ()
\begin{DoxyCompactList}\small\item\em Gets the value of the \char`\"{}is\+\_\+done\char`\"{} flag. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classQueue_a0984ba1a6d1e8de2275d7b5f89bb12fa}{queue\+\_\+size}} ()
\begin{DoxyCompactList}\small\item\em Gets the maximum capacity of the queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classQueue_a23ea6a9188e196f40cbb4e15b08c1e53}{push}} (T element, int timeout\+\_\+ms=0)
\begin{DoxyCompactList}\small\item\em Pushes an element into the queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classQueue_a4586ef0e5b058949810ce87487715492}{pop}} (T \&item, int timeout\+\_\+ms=0)
\begin{DoxyCompactList}\small\item\em Pops an element from the queue. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class Queue$<$ T $>$}

A thread-\/safe queue implementation. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type of elements stored in the queue. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classQueue_a66872b8cc7fc722d02c14bb5816ab2c2}\label{classQueue_a66872b8cc7fc722d02c14bb5816ab2c2}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!Queue@{Queue}}
\index{Queue@{Queue}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Queue()}{Queue()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::\mbox{\hyperlink{classQueue}{Queue}} (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a new \mbox{\hyperlink{classQueue}{Queue}} object. 


\begin{DoxyParams}{Parameters}
{\em n} & The maximum capacity of the queue. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{29                      \{}
\DoxyCodeLine{30             this-\/>queue\_capacity = n;}
\DoxyCodeLine{31             \textcolor{keywordflow}{if} (pthread\_mutex\_init(\&mutex\_lock, NULL)) \{}
\DoxyCodeLine{32                 fprintf(stderr, \textcolor{stringliteral}{"Unable to initialize the mutex\(\backslash\)n"});}
\DoxyCodeLine{33             \}}
\DoxyCodeLine{34         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_aa7eef1b427e24555780505de20e9acbc}\label{classQueue_aa7eef1b427e24555780505de20e9acbc}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!````~Queue@{$\sim$Queue}}
\index{````~Queue@{$\sim$Queue}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$Queue()}{~Queue()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::$\sim$\mbox{\hyperlink{classQueue}{Queue}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destroys the \mbox{\hyperlink{classQueue}{Queue}} object. 


\begin{DoxyCode}{0}
\DoxyCodeLine{39                  \{}
\DoxyCodeLine{40             pthread\_mutex\_destroy(\&mutex\_lock);}
\DoxyCodeLine{41             pthread\_cond\_destroy(\&cond\_read);}
\DoxyCodeLine{42             pthread\_cond\_destroy(\&cond\_write);}
\DoxyCodeLine{43         \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classQueue_ad2779bcb60e23b597662c393bf04271c}\label{classQueue_ad2779bcb60e23b597662c393bf04271c}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!count@{count}}
\index{count@{count}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Gets the number of elements in the queue. 

\begin{DoxyReturn}{Returns}
The number of elements in the queue. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{50                     \{}
\DoxyCodeLine{51             \textcolor{keywordflow}{return} this-\/>m\_queue.size();}
\DoxyCodeLine{52         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_a22e0b575ea62157eaf947b6845d0b560}\label{classQueue_a22e0b575ea62157eaf947b6845d0b560}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!get\_is\_done@{get\_is\_done}}
\index{get\_is\_done@{get\_is\_done}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{get\_is\_done()}{get\_is\_done()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::get\+\_\+is\+\_\+done (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Gets the value of the \char`\"{}is\+\_\+done\char`\"{} flag. 

\begin{DoxyReturn}{Returns}
The value of the \char`\"{}is\+\_\+done\char`\"{} flag. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{66                           \{}
\DoxyCodeLine{67             \textcolor{keywordflow}{return} this-\/>is\_done;}
\DoxyCodeLine{68         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_a4586ef0e5b058949810ce87487715492}\label{classQueue_a4586ef0e5b058949810ce87487715492}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!pop@{pop}}
\index{pop@{pop}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{pop()}{pop()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::pop (\begin{DoxyParamCaption}\item[{T \&}]{item,  }\item[{int}]{timeout\+\_\+ms = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pops an element from the queue. 

This function pops an element from the queue, blocking if the queue is empty.


\begin{DoxyParams}{Parameters}
{\em item} & A reference to the variable where the popped element will be stored. \\
\hline
{\em timeout\+\_\+ms} & The maximum time in milliseconds to wait if the queue is empty. Default is 0 (no timeout). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if an element was successfully popped from the queue, false if the pop operation timed out or if the queue is empty.
\end{DoxyReturn}

\begin{DoxyItemize}
\item If the current number of elements in the queue is 0, indicating that the queue is empty, the function waits for the write condition to be signaled (indicating that a writer has pushed an element into the queue).
\item If a timeout (specified by {\ttfamily timeout\+\_\+ms}) is provided and the write condition is not signaled within the given time, the pop operation times out and returns false.
\item If no timeout is specified ({\ttfamily timeout\+\_\+ms} = 0) and the queue is empty, the function waits indefinitely until the write condition is signaled.
\item After successfully popping an element from the queue, the function assigns the popped element to the {\ttfamily item} parameter and removes it from the queue.
\item The function also signals the read condition if the number of elements in the queue becomes (queue\+\_\+capacity -\/ 1). This indicates to potential writers that there is space available in the queue for pushing new elements.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
This function should be called by the reader thread. 
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{161                                               \{}
\DoxyCodeLine{162             \textcolor{keywordtype}{bool} status = \textcolor{keyword}{true};}
\DoxyCodeLine{163             pthread\_mutex\_lock(\&mutex\_lock);}
\DoxyCodeLine{164             \textcolor{keywordflow}{if} (0 == this-\/>\mbox{\hyperlink{classQueue_ad2779bcb60e23b597662c393bf04271c}{count}}()) \{}
\DoxyCodeLine{165                 std::cout << \textcolor{stringliteral}{"pop: queue is empty\(\backslash\)n"};}
\DoxyCodeLine{166                 \textcolor{keywordflow}{if} (timeout\_ms > 0) \{}
\DoxyCodeLine{167                     \textcolor{keyword}{struct }timespec time\_spec;}
\DoxyCodeLine{168                     clock\_gettime(CLOCK\_REALTIME, \&time\_spec);}
\DoxyCodeLine{169                     time\_spec.tv\_sec += timeout\_ms / 1000;}
\DoxyCodeLine{170                     time\_spec.tv\_nsec += (timeout\_ms \% 1000) * 1000000;}
\DoxyCodeLine{171                     \textcolor{keywordflow}{if} (time\_spec.tv\_nsec > 1000000000) \{}
\DoxyCodeLine{172                         time\_spec.tv\_sec += 1;}
\DoxyCodeLine{173                         time\_spec.tv\_nsec -\/= 1000000000;}
\DoxyCodeLine{174                     \}}
\DoxyCodeLine{175                     \textcolor{keywordflow}{if} (0 != pthread\_cond\_timedwait(\&cond\_write, \&mutex\_lock, \&time\_spec)) \{}
\DoxyCodeLine{176                         status = \textcolor{keyword}{false};}
\DoxyCodeLine{177                         std::cout << \textcolor{stringliteral}{"pop: timeout\(\backslash\)n"};}
\DoxyCodeLine{178                         }
\DoxyCodeLine{179                     \}}
\DoxyCodeLine{180                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{181                     pthread\_cond\_wait(\&cond\_write, \&mutex\_lock);}
\DoxyCodeLine{182                 \}}
\DoxyCodeLine{183             \}}
\DoxyCodeLine{184             }
\DoxyCodeLine{185             \textcolor{keywordflow}{if} (\textcolor{keyword}{true} == status) \{}
\DoxyCodeLine{186                 item = this-\/>m\_queue.front();}
\DoxyCodeLine{187                 this-\/>m\_queue.pop();}
\DoxyCodeLine{188                 std::cout << \textcolor{stringliteral}{"pop: element popped out\(\backslash\)n"};}
\DoxyCodeLine{189                 \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classQueue_ad2779bcb60e23b597662c393bf04271c}{count}}() == (this-\/>queue\_capacity -\/ 1)) \{}
\DoxyCodeLine{190                     pthread\_cond\_signal(\&cond\_read);}
\DoxyCodeLine{191                     std::cout << \textcolor{stringliteral}{"pop: signalled push\(\backslash\)n"};}
\DoxyCodeLine{192                 \}}
\DoxyCodeLine{193             \}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195             pthread\_mutex\_unlock(\&mutex\_lock);}
\DoxyCodeLine{196             std::cout << \textcolor{stringliteral}{"pop: released lock\(\backslash\)n"};}
\DoxyCodeLine{197 }
\DoxyCodeLine{198             \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{199         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_a23ea6a9188e196f40cbb4e15b08c1e53}\label{classQueue_a23ea6a9188e196f40cbb4e15b08c1e53}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!push@{push}}
\index{push@{push}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::push (\begin{DoxyParamCaption}\item[{T}]{element,  }\item[{int}]{timeout\+\_\+ms = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pushes an element into the queue. 

This function pushes the given element into the queue, blocking if the queue is full.


\begin{DoxyParams}{Parameters}
{\em element} & The element to be pushed into the queue. \\
\hline
{\em timeout\+\_\+ms} & The maximum time in milliseconds to wait if the queue is full. Default is 0 (no timeout). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the element was successfully pushed into the queue, false if the push operation timed out or if the maximum number of elements (10) has been reached.
\end{DoxyReturn}

\begin{DoxyItemize}
\item If the current number of elements in the queue is equal to the queue\textquotesingle{}s capacity, the function waits for the read condition to be signaled (indicating that a reader has consumed an element from the queue).
\item If a timeout (specified by {\ttfamily timeout\+\_\+ms}) is provided and the read condition is not signaled within the given time, the push operation times out and returns false.
\item If no timeout is specified ({\ttfamily timeout\+\_\+ms} = 0) and the queue is full, the function waits indefinitely until the read condition is signaled.
\item After successfully pushing the element into the queue, the function signals the write condition to notify potential readers that there is data available for consumption.
\item The function also increments the {\ttfamily write\+\_\+counts} variable to keep track of the number of successful push operations. If {\ttfamily write\+\_\+counts} reaches 10, indicating that the maximum number of elements has been reached, the {\ttfamily is\+\_\+done} flag is set to true, and subsequent push operations will return false.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
This function should be called by the writer thread. 
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{97                                                  \{}
\DoxyCodeLine{98             \textcolor{keywordtype}{bool} status = \textcolor{keyword}{true};}
\DoxyCodeLine{99             write\_counts++;}
\DoxyCodeLine{100             \textcolor{keywordflow}{if} (10 < write\_counts) \{}
\DoxyCodeLine{101                 this-\/>is\_done = \textcolor{keyword}{true};}
\DoxyCodeLine{102                 status = \textcolor{keyword}{false};}
\DoxyCodeLine{103                 \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{104             \} }
\DoxyCodeLine{105             }
\DoxyCodeLine{106             pthread\_mutex\_lock(\&mutex\_lock);}
\DoxyCodeLine{107             std::cout << \textcolor{stringliteral}{"push: acquired lock\(\backslash\)n"};}
\DoxyCodeLine{108             \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classQueue_ad2779bcb60e23b597662c393bf04271c}{count}}() == this-\/>\mbox{\hyperlink{classQueue_a0984ba1a6d1e8de2275d7b5f89bb12fa}{queue\_size}}()) \{}
\DoxyCodeLine{109                 std::cout << \textcolor{stringliteral}{"push: queue is full\(\backslash\)n"};}
\DoxyCodeLine{110                 \textcolor{keywordflow}{if} (timeout\_ms > 0) \{}
\DoxyCodeLine{111                     \textcolor{keyword}{struct }timespec time\_spec;}
\DoxyCodeLine{112                     clock\_gettime(CLOCK\_REALTIME, \&time\_spec);}
\DoxyCodeLine{113                     time\_spec.tv\_sec += timeout\_ms / 1000;}
\DoxyCodeLine{114                     time\_spec.tv\_nsec += (timeout\_ms \% 1000) * 1000000;}
\DoxyCodeLine{115                     \textcolor{keywordflow}{if} (time\_spec.tv\_nsec > 1000000000) \{}
\DoxyCodeLine{116                         time\_spec.tv\_sec += 1;}
\DoxyCodeLine{117                         time\_spec.tv\_nsec -\/= 1000000000;}
\DoxyCodeLine{118                     \}}
\DoxyCodeLine{119                     \textcolor{keywordflow}{if} (pthread\_cond\_timedwait(\&cond\_read, \&mutex\_lock, \&time\_spec) == ETIMEDOUT) \{}
\DoxyCodeLine{120                         status = \textcolor{keyword}{false};}
\DoxyCodeLine{121                         std::cout << \textcolor{stringliteral}{"push: timeout\(\backslash\)n"};}
\DoxyCodeLine{122                     \}}
\DoxyCodeLine{123                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{124                     pthread\_cond\_wait(\&cond\_read, \&mutex\_lock);}
\DoxyCodeLine{125                 \}}
\DoxyCodeLine{126             \} }
\DoxyCodeLine{127             }
\DoxyCodeLine{128             \textcolor{keywordflow}{if} (status == \textcolor{keyword}{true}) \{}
\DoxyCodeLine{129                 this-\/>m\_queue.push(element);}
\DoxyCodeLine{130                 std::cout << \textcolor{stringliteral}{"push: pushed "} << element << \textcolor{stringliteral}{" into the queue\(\backslash\)n"};}
\DoxyCodeLine{131                 \textcolor{keywordflow}{if} (1 == this-\/>\mbox{\hyperlink{classQueue_ad2779bcb60e23b597662c393bf04271c}{count}}()) \{}
\DoxyCodeLine{132                     pthread\_cond\_signal(\&cond\_write);}
\DoxyCodeLine{133                     std::cout << \textcolor{stringliteral}{"push: signaled to pop\(\backslash\)n"};}
\DoxyCodeLine{134                 \}}
\DoxyCodeLine{135             \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137             pthread\_mutex\_unlock(\&mutex\_lock);}
\DoxyCodeLine{138             std::cout << \textcolor{stringliteral}{"push: released lock\(\backslash\)n"};}
\DoxyCodeLine{139 }
\DoxyCodeLine{140             \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{141         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_a0984ba1a6d1e8de2275d7b5f89bb12fa}\label{classQueue_a0984ba1a6d1e8de2275d7b5f89bb12fa}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!queue\_size@{queue\_size}}
\index{queue\_size@{queue\_size}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{queue\_size()}{queue\_size()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::queue\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Gets the maximum capacity of the queue. 

\begin{DoxyReturn}{Returns}
The maximum capacity of the queue. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{75                          \{}
\DoxyCodeLine{76             \textcolor{keywordflow}{return} this-\/>queue\_capacity;}
\DoxyCodeLine{77         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classQueue_a03312b60344e10adc76501434b2852f6}\label{classQueue_a03312b60344e10adc76501434b2852f6}} 
\index{Queue$<$ T $>$@{Queue$<$ T $>$}!set\_is\_done@{set\_is\_done}}
\index{set\_is\_done@{set\_is\_done}!Queue$<$ T $>$@{Queue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{set\_is\_done()}{set\_is\_done()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \mbox{\hyperlink{classQueue}{Queue}}$<$ T $>$\+::set\+\_\+is\+\_\+done (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the \char`\"{}is\+\_\+done\char`\"{} flag to indicate the producer is done. 


\begin{DoxyCode}{0}
\DoxyCodeLine{57                            \{}
\DoxyCodeLine{58             this-\/>is\_done = 1;}
\DoxyCodeLine{59         \}}

\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/zeishan/\+Documents/jun-\/19-\/bosch/bosch-\/assign/\mbox{\hyperlink{bosch-assign_8hpp}{bosch-\/assign.\+hpp}}\end{DoxyCompactItemize}
